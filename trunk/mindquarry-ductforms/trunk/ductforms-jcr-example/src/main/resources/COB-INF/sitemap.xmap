<?xml version="1.0" encoding="UTF-8"?>
<!--
	Copyright 2006 The Apache Software Foundation
	
	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
	
	http://www.apache.org/licenses/LICENSE-2.0
	
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
-->
<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">
	<map:components>

		<map:serializers>
			<map:serializer logger="sitemap.serializer.html"
				mime-type="text/html" name="html" pool-max="32"
				src="org.apache.cocoon.serialization.HTMLSerializer">
				<doctype-public>
					-//W3C//DTD HTML 4.01 Transitional//EN
				</doctype-public>
				<doctype-system>
					http://www.w3.org/TR/html4/loose.dtd
				</doctype-system>
				<encoding>UTF-8</encoding>
			</map:serializer>
		</map:serializers>

		<map:transformers default="xslt">
			<!-- the browser-update transformer is needed for AJAX -->
			<map:transformer name="browser-update"
				src="org.apache.cocoon.ajax.BrowserUpdateTransformer" />
			<!-- this is obviously for internationalization -->
			<map:transformer name="i18n"
				src="org.apache.cocoon.transformation.I18nTransformer">
				<!-- neccessary resources for internationalization -->
				<catalogues default="other">
					<catalogue id="other" name="OtherMessages"
						location="messages" />
					<catalogue id="forms" name="messages"
						location="resource://org/apache/cocoon/forms/system/i18n" />
				</catalogues>
				<cache-at-startup>true</cache-at-startup>
			</map:transformer>
		</map:transformers>

		<map:generators default="file">
			<!--<map:generator name="file"
				src="org.apache.cocoon.generation.FileGenerator"/>-->
			<map:generator name="traversable"
				src="org.apache.cocoon.generation.TraversableGenerator">
			</map:generator>

			<map:generator label="content,data"
				logger="sitemap.generator.profiler" name="profiler"
				src="org.apache.cocoon.generation.ProfilerGenerator" />
		</map:generators>

		<map:selectors>
			<!-- this selector returns true if there is an ajax request -->
			<map:selector name="ajax-request"
				src="org.apache.cocoon.ajax.AjaxRequestSelector" />
		</map:selectors>

		<map:pipes default="caching">
			<!-- The following two can be used for profiling:-->
			<map:pipe name="profile-caching"
				src="org.apache.cocoon.components.profiler.ProfilingCachingProcessingPipeline" />
			<map:pipe name="profile-noncaching"
				src="org.apache.cocoon.components.profiler.ProfilingNonCachingProcessingPipeline" />
		</map:pipes>

	</map:components>

	<map:flow language="javascript">
		<map:script src="ductforms.js" />
	</map:flow>

	<map:resources>
		<!-- call this resource instead of the normal html serializer -->
		<map:resource name="layouting">
			<!--<map:transform src="resource://com/mindquarry/webapp/xsl/html2html.xsl">-->
			<map:transform src="xslt/html/html2html.xsl">
				<map:parameter name="pathInfo"
					value="{request:pathInfo}" />
			</map:transform>
			<map:serialize type="xhtml" />
		</map:resource>
	</map:resources>

	<map:views>
		<map:view name="pretty-content" from-label="data">
			<map:transform src="simple-xml2html.xslt" />
			<map:serialize type="html" />
		</map:view>
	</map:views>
	
	<map:pipelines>
		<map:pipeline type="profile-noncaching">
    
      <map:match pattern="status.xml">
        <map:generate type="status">
          <map:parameter name="show-cont" value="true"/>
        </map:generate>
        <!--<map:transform src="xslt/html/contextpath.xsl">
          <map:parameter name="pathInfo"
            value="{request:pathInfo}" />
        </map:transform>-->
        <map:transform src="status2html.xslt">
          <map:parameter name="pathInfo" value="{request:pathInfo}"/>
        </map:transform>
        <map:serialize type="xhtml" />
      </map:match>

			<!-- the pipelines for resources for status2html.xslt -->
			<map:match pattern="styles/*">
				<map:read src="resources/styles/{1}" />
			</map:match>
			<map:match pattern="scripts/*">
				<map:read src="resources/scripts/{1}" />
			</map:match>

			<!-- the aggregation of all datamodel desctiptions available in the system -->
			<map:match pattern="model.xml">
				<map:generate src="model" type="directory" />
				<map:transform src="xslt/ductforms/directory2model.xsl" />
				<map:transform type="xinclude" />
				<map:serialize type="xml" />
			</map:match>
			<!-- the aggregation of all query model descriptions available -->
			<map:match pattern="query.xml">
				<map:generate src="query" type="directory" />
				<map:transform src="xslt/ductforms/directory2model.xsl" />
				<map:transform type="xinclude" />
				<map:serialize type="xml" />
			</map:match>

			<!-- the raw content of the xml document, only for further processing and debugging -->
			<map:match pattern="*.xml.raw">
				<map:generate src="jcr:///test/{1}.xml" />
				<map:serialize type="xml" />
			</map:match>

			<!--+ the true content of the model, here required fields have been added and
				| redundant declaration of the fields included is added
				+-->
			<map:match pattern="*.xml.plain">
				<map:select type="resource-exists">
					<!-- if it exists, show the list of jobs -->
					<map:when test="jcr:///test/{1}.xml">
						<map:generate src="jcr:///test/{1}.xml" />
						<map:transform
							src="xslt/ductforms/addfield.xsl" />
						<map:serialize type="xml" />
					</map:when>
					<map:otherwise>
						<map:generate src="cocoon:/model.xml" />
						<map:transform
							src="xslt/ductforms/plainmodel.xsl" />
						<map:serialize type="xml" />
					</map:otherwise>
				</map:select>
			</map:match>

			<!--+ the aggregation of the plain instance (data of the document)
				| and the aggregated models. This includes everything that is
				| and could be.
				+-->
			<map:match pattern="*.xml.model">
				<map:generate src="cocoon:/model.xml" />
				<map:transform
					src="xslt/ductforms/model2modelinclude.xsl">
					<map:parameter name="instance"
						value="cocoon:/{1}.xml.plain">
					</map:parameter>
				</map:transform>
				<map:transform type="xinclude" />
				<map:transform src="xslt/ductforms/cleanmodel.xsl" />
				<map:serialize type="xml" />
			</map:match>

			<!-- the generated form model including all possible fields  -->

			<map:match pattern="*.xml.form">
				<map:generate src="cocoon:/{1}.xml.model" />
				<map:transform
					src="xslt/ductforms/modelincluded2form.xsl" />
				<map:serialize type="xml" />
			</map:match>

			<!-- the generated form template including only the selected fields -->

			<map:match pattern="*.xml.template">
				<map:generate src="cocoon:/{1}.xml.model" />
				<map:transform
					src="xslt/ductforms/modelincluded2template.xsl" />
				<map:serialize type="xml" />
			</map:match>

			<!-- the form instance, or the document in edit mode -->

			<map:match pattern="*.xml.edit">
				<map:call function="handleForm">
					<map:parameter name="function" value="editPage" />
					<map:parameter name="page" value="{1}" />
					<!-- in the original example this was configurable -->
					<!-- <map:parameter name="renderMode" value="jx" /> -->
					<map:parameter name="definitionURI"
						value="cocoon:/{1}.xml.form" />
				</map:call>
			</map:match>

			<!-- the document in presentation mode -->

			<map:match pattern="*.xml">
				<map:select type="resource-exists">
					<!-- if it exists, show the list of jobs -->
					<map:when test="jcr:///test/{1}.xml">
						<map:call function="handleForm">
							<map:parameter name="function"
								value="showPage" />
							<map:parameter name="page" value="{1}" />
							<!-- in the original example this was configurable -->
							<!-- <map:parameter name="renderMode" value="jx" /> -->
							<map:parameter name="definitionURI"
								value="cocoon:/{1}.xml.form" />
						</map:call>
					</map:when>
					<map:otherwise>
						<map:redirect-to uri="{1}.xml.edit" />
					</map:otherwise>
				</map:select>
			</map:match>

			<!-- the overview pages (query) -->

			<map:match pattern="*.query.raw">
				<map:generate type="traversable" src="jcr:///test" />
				<map:transform src="xslt/jcr/collection2new.xsl" />
				<!--<map:transform
					src="xslt/jcr/collection2aggregate.xsl" />-->
				<map:transform type="cinclude" />
				<map:serialize type="xml" />
			</map:match>

			<map:match pattern="*.query.xsl">
				<map:generate src="query/{1}.xsl" />
				<map:transform src="xslt/ductforms/query2xsl.xsl" />
				<map:serialize type="xml" />
			</map:match>

			<map:match pattern="*.query">
				<map:generate src="cocoon:/{1}.query.raw" />
				<map:transform src="cocoon:/{1}.query.xsl" />
				<map:call resource="layouting" />
				<!--<map:serialize type="html" />-->
			</map:match>

			<!-- start page (or any other page) -->

			<map:match pattern="">
				<!-- test for existance of a collection -->
				<map:select type="resource-exists">
					<!-- if it exists, show the basic overview page -->
					<map:when test="jcr:///test/">
						<map:redirect-to uri="index.query" />
					</map:when>
					<!-- if not, initialize the repository -->
					<map:otherwise>
						<map:generate src="jcr/populate.xml" />
						<map:transform type="write-source" />
						<map:transform src="xslt/jcr/populate2html.xsl" />
						<map:serialize type="html" />
					</map:otherwise>
				</map:select>
			</map:match>

			<!-- the form rendering pipeline called by the form controller -->

			<map:match pattern="*.xml.instance">
				<!-- get the form template from a dynamic pipeline -->
				<map:generate type="jx" src="cocoon:/{1}.xml.template"
					label="content1">
					<map:parameter name="locale"
						value="{flow-attribute:locale}" />
				</map:generate>

				<!-- beautify our forms -->
				<map:transform src="xslt/ductforms/instance2html.xsl">
					<map:parameter name="page" value="{1}" />
				</map:transform>

				<!-- standard cocoon form2html stylesheet + dojo-editor -->
				<map:transform src="xslt/forms/form2html.xsl">
					<map:parameter name="resources-uri"
						value="{request:contextPath}/_cocoon/resources" />
				</map:transform>

				<!-- convert escaped html in dojo-editor content (marked with
					htmllize tags) into real html (nekohtml from cocoon-html) -->
				<map:transform type="nekohtml">
					<map:parameter name="tags" value="htmllize" />
				</map:transform>

				<map:transform src="xslt/forms/htmllize.xsl" />

				<map:serialize type="html" />
			</map:match>


			<!-- the pipeline for resources like images -->
			<map:match pattern="resources/*/**">
				<map:read src="{1}/{2}" />
			</map:match>

			<!-- Continue a scenario. The continuation id is passed in the URL
				(typically used for GET requests) -->
			<map:match pattern="*.continue">
				<map:call continuation="{1}" />
			</map:match>

			<!-- Continue a scenario. The continuation id is passed as a request
				parameter (typically used for POST request) -->
			<map:match pattern="continue">
				<map:call continuation="{1}" />
			</map:match>

			<map:match pattern="profile.html">
				<map:generate type="profiler" />
				<map:transform src="profile2html.xsl">
					<map:parameter name="use-request-parameters"
						value="true" />
				</map:transform>
				<map:serialize type="html" />
			</map:match>

			<map:match pattern="profile.xml">
				<map:generate type="profiler" />
				<map:serialize type="xml" />
			</map:match>

		    <!--+
		        | At the very end of a pipeline, you can catch the errors triggered
		        | by the pipeline execution. The error handler is an internal sitemap
		        | component that, when triggered by an error, takes over the normal
		        | pipeline execution.
		        | You can here use the "notifying" generator that produces an XML
		        | representation and further manipulate this document for presentation
		        | on screen.
		        | You can also use any other generator if you don't want the
		        | error to be displayed on screen. The "exception" selector can help
		        | you to define different screens for different error types.
		        +-->
		    <map:handle-errors>
		      <map:select type="exception">
		
		        <map:when test="not-found">
		          <map:generate type="exception"/>
		          <map:transform src="system/exception2html.xslt">
		            <map:parameter name="contextPath" value="{request:contextPath}"/>
		            <map:parameter name="realPath" value="{realpath:}"/>
		            <map:parameter name="pageTitle" value="Resource not found"/>
		          </map:transform>
		          <map:serialize status-code="404"/>
		        </map:when>
		
		        <map:when test="invalid-continuation">
		          <map:generate type="exception"/>
		          <map:transform src="system/exception2html.xslt">
		            <map:parameter name="contextPath" value="{request:contextPath}"/>
		            <map:parameter name="realPath" value="{realpath:}"/>
		            <map:parameter name="pageTitle" value="Invalid Continuation"/>
		          </map:transform>
		          <map:serialize status-code="404"/>
		        </map:when>
		
		        <map:otherwise>
		          <map:generate type="exception"/>
		          <map:transform src="system/exception2html.xslt">
		            <map:parameter name="contextPath" value="{request:contextPath}"/>
		            <map:parameter name="realPath" value="{realpath:}"/>
		          </map:transform>
		          <map:serialize status-code="500"/>
		        </map:otherwise>
		      </map:select>
		
		    </map:handle-errors>

		</map:pipeline>

	</map:pipelines>

</map:sitemap>

